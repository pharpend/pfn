\chapter{Standard IO}

Our goal at the end of this chapter is to write a program that does
the following things, in a loop:

\begin{enumerate}
\item Read a piece of text from the user.
\item Print out the text but reversed.
\item If the user inputs `exit', then the program exits, but before
  we print out the reversed text.
\end{enumerate}

Vocabulary term: a piece of text is called a \term{string}.

To print out the text, use the \code{print()} function. To read text
input, we use the \code{input()} function. Examples:

\lstpy{input-example.txt}

Knowing about the function \code{input()} is a piece of trivia, that,
in the grand scheme of things, is unimportant. However, being able to
apply the thought process and techniques in this section to similar
problems is very important.

The broadest technique in programming is to break a problem down into
smaller problems. Here is how I would break down this problem:

\begin{enumerate}
\item start up the program;
\item read a string from the user using \code{input()};
\item if the string is \code{exit}, then die;
\item else, reverse the string;
\item print the reversed string;
\item go back to 2.
\end{enumerate}

There are four important concepts in my breakdown:

\begin{enumerate}
\item the \term{variable}, i.e. storing and changing a value;
\item the \term{conditional}, i.e. if A then B else C;
\item the \term{loop}, i.e. ``go back to 2;''
\item a \term{subroutine}, where we delegate repetitive tasks to
  smaller programs stored inside our main program.
\end{enumerate}

The latter three concepts are examples of \term{flow control
  structures}. We'll learn more about them in this
chapter. Conditional statements are broad enough that they require
their own section.

\section{Variables}

The first thing is a variable. Most people are familiar with the
concept of a variable from mathematics courses. In most programming
languages, a variable can actually vary. So, for instance, in math,
this is (more or less) nonsense:

\begin{align*}
  a & = 2 \\
  a & = a + 10 \\
  a & \text{ is now equal to 12.}
\end{align*}

At the very least, it's rather uncommon. However, in most programming
languages, it's extremely common. It's the most fundamental and common
thing you do. Here's how we'd represent that in Python:

\lstpy{python-var-1.txt}

Every variable (indeed, every value) has a \term{type}. To get the
type of an object in Python, you use the \code{type()} function:

\lstpy{python-types-1.txt}

\begin{remark}
  In Python, types are less important, because Python uses \term{weak
    typing}, and \term{dynamic typing}, where Python does not actually
  determine the type of each object until it actually runs the
  code. However, in certain programming languages (languages with
  \term{static typing} and \term{strong typing}), types are extremely
  important.

  Weak typing is a fundamental weakness of Python, and indeed all
  weakly typed languages, including Ruby. Small mental errors can
  translate into impossible-to-find bugs in your code, that may take
  several days to find, let alone fix. This is why I strongly prefer
  static and strongly typed languages, such as Haskell. In Haskell,
  most bugs are caught before you even compile the software.

  If you take strong typing to the extreme, you get languages like
  Idris and Coq, where the type system is strong enough that you can
  actually mathematically prove the correctness of your program with
  the type system.
\end{remark}

\begin{remark}
  Fair warning: my experience is predominantly in \term{functional}
  programming languages, which do not have the concept of varying
  variables. Therefore, much of the code I write will not use the
  ``Pythonic'' method, and will instead employ a more Haskell-like
  approach.
\end{remark}

\subsection{Legal variable names}

Python, and indeed every language, has rules about legal variable
names:

\begin{enumerate}
\item variable names \emph{must} start with a letter or an underscore;
\item variable names \emph{should} start with a lowercase letter or an
  underscore;
\item variable names may only contain letters, numbers, and underscores;
\item variable names are case-sensitive;
\item separate words in variables should use the \code{snake_case}
  convention (as opposed to the \code{idontknowwhatwordsare} or
  \code{camelCase} conventions).
\end{enumerate}

\begin{exercise}
  What do you suppose the types of these values are? Check your
  guesses in the REPL:

  \begin{enumerate}
  \item \code{2 + 2}
  \item \code{28 / 13}
  \item \code{28 / 14}
  \item \code{'hello, my name is joe'}
  \end{enumerate}
\end{exercise}

\begin{exercise}
  What do you think the following program does?

  \pyfile{code/print_plus_3.py}

  \xtb{Hint}: \emph{\code{int(x)} takes any value and tries to convert
    it to an integer. It might be worth toying around with
    \code{int()} in the REPL.}

  Try it and see.
\end{exercise}

\begin{exercise}
  Which of the following are legal variable names?

  \begin{enumerate}
  \item \code{Hello_my_name_is_Peter!}
  \item \code{Hello_my_name_is_Peter}
  \item \code{one+one_equals_2}
  \item \code{one_plus_one_equals_2}
  \item \code{n00b}
  \item \code{0perator}
  \end{enumerate}

  Try these out in the REPL (assign each name the value of \code{0} or
  something).
\end{exercise}

\section{Conditionals and Boolean algebra}

Conditional statements, i.e. if/then/else, are based on
\term{Booleans}\footnote{``Boolean'' is capitalized because it is
  named after an English mathematician, George Boole.}.

\begin{definition}
  A Boolean is either true or false.
\end{definition}

The study and manipulation of Booleans is called \term{Boolean
  algebra}. Let's explore Booleans in Python:

\lstpy{python-bools-1.txt}

In our goal, we want to be able to create a Boolean that tells us
whether or not the string is `exit'.

\subsection{Combining Booleans}

Booleans are kind of useless unless you can

\begin{enumerate}
\item combine them to make new Booleans, and
\item use them to determine whether or not to do something.
\end{enumerate}

There are three common ways to combine Booleans:

\begin{enumerate}
\item negation, where \code{not True = False}, and \code{not False =
    True};
\item an ``and'' statement, such as \code{a and b}, which is true if
  and only if both \code{a} and \code{b} are true;
\item an ``or'' statement, such as \code{a or b}, which is true if and
  only if at least one of \code{a} and \code{b} is true.
\end{enumerate}

\lstpy{python-bools-1.txt}

A common exercise is to build a \term{truth table} for the
operations. I've already given you some of the answers with my example

\begin{table}
  \centering
  \begin{tabu}{r|c|c}
    \code{and} & \code{True} & \code{False} \\
    \tabucline \\
    \code{True} & \code{True} & \code{False} \\
    \tabucline \\
    \code{False} & & \\
  \end{tabu}
  \caption{Partially filled in truth table for \code{and}.}
  \label{tbl:truth-table-and}
\end{table}

\begin{table}
  \centering
  \begin{tabu}{r|c|c}
    \code{or} & \code{True} & \code{False} \\
    \tabucline \\
    \code{True} & & \code{True} \\
    \tabucline \\
    \code{False} & & \code{False} \\
  \end{tabu}
  \caption{Partially filled in truth table for \code{or}.}
  \label{tbl:truth-table-or}
\end{table}

The next thing is negation:

\lstpy{python-negation-1.txt}

This immediately gives rise to the following lemma, which is obvious:

\begin{lemma}
  \label{thm:double-neg-bool}
  For all Booleans \code{a}, \code{not (not a)} is equal to \code{a}.
\end{lemma}

It is not all that interesting. However, the following properties,
called \term{De Morgan's laws}, are:

\begin{lemma}
  \label{thm:de-morgan-1}
  For all Booleans \code{a} and \code{b}, \code{not (a and b)} is
  equal to \code{(not a) or (not b)}.
\end{lemma}

Think about it:

\begin{enumerate}
\item I told you that I went to the park and the grocery store;
\item but you know that I didn't go to the park, or that I didn't go
  to the grocery store;
\item then I lied to you.
\end{enumerate}

The converse is also true:

\begin{enumerate}
\item I told you that I didn't go to the park or I didn't go to the grocery store;
\item but you know that I did in fact go to the park, and that I did
  go to the grocery store;
\item then I lied to you.
\end{enumerate}

It might help to compute a few of these values in the REPL, or just
make a truth table (\cref{exc:de-morgan-table-1}).

This corollary can be obtained by combining \cref{thm:double-neg-bool}
and \cref{thm:de-morgan-1}:

\begin{corollary}
  \label{thm:de-morgan-2}
  For all Booleans \code{a} and \code{b}, \code{not (a or b)} is equal
  to \code{(not a) or (not b)}.
\end{corollary}

If you're not convinced, think about it for a second, or build a truth
table (\cref{exc:de-morgan-table-2}).

Next, we have the \term{distributive laws}:

\begin{lemma}
  For all Booleans \code{a}, \code{b}, and \code{c}, \code{a and (b or
    c)} is equal to \code{(a and b) or (a and c)}.
\end{lemma}

This is similar to the distributive law in math, for real
numbers: $$a(b + c) = ab + ac.$$ This is also true:

\begin{lemma}
  For all Booleans \code{a}, \code{b}, and \code{c}, \code{a or (b and
    c)} is equal to \code{(a or b) and (a or c)}.
\end{lemma}

The analog doesn't hold in math: $$a + bc \ne (a + b)(b + c).$$

\subsection{Testing for equality, and other mathematical tests}

It's tiring to put ``is equal to'' every time. Instead, Python has the
\code{==} operator:

\lstpy{python-equals-equals.txt}

\begin{remark}
  It's important to note that \code{a == b} \emph{tests} to see if
  \code{a} and \code{b} are equal, whereas \code{a = b} \emph{assigns}
  \code{a} to whatever \code{b} is.
\end{remark}

The analog of $\ne$ is \code{!=}:

\begin{lstlisting}[language=Python]
>>> 2 != 4
True
>>> 2 != 2
False
\end{lstlisting}

\Cref{tbl:math-python} might be helpful.

\begin{table}
  \centering
  \begin{tabu}{r|l}
    \textbf{Math} & \textbf{Python} \\
    \tabucline \\
    $a := b$ & \code{a = b} \\
    $a = b$ & \code{a == b} \\
    $a \ne b$ & \code{a != b} \\
    $a > b$ & \code{a > b} \\
    $a \ge b$ & \code{a >= b} \\
    $a < b$ & \code{a < b} \\
    $a \le b$ & \code{a <= b} \\
  \end{tabu}
  \caption{Mathematical statements, and their equivalent in Python}
  \label{tbl:math-python}
\end{table}

\subsection{If/then/else}

Now that you understand what Booleans are, we need to be able to
instruct Python to

\begin{enumerate}
\item given a Boolean \code{b};
\item if \code{b} is true, do something;
\item if \code{b} is false, do something else.
\end{enumerate}

In Python, this is achieved via the \code{if} clause. The general
syntax is

\begin{lstlisting}[language=Python]
if b:
    # do something here
else:
    # do something different
\end{lstlisting}

The \code{#} represents a comment, which is ignored.

\begin{remark}
  The above is not valid code, because you'd need actual code inside
  the \code{if} and \code{else} blocks, rather than just a comment.
\end{remark}

\begin{remark}
  Please note the trailing colons after \code{if b} and
  \code{else}. It's really easy to forget them.
\end{remark}

Let's look at a simple program that takes in two numbers from the
user, and checks if their sum is $20$.

\pyfile{code/sum_is_twenty.py}

Here's an example input:

\lstin{sum_is_twenty.txt}

Often times, if the first condition fails to be true, you'll want to
test for other conditions inside the \code{else} block:

\begin{lstlisting}[language=Python]
if b1:
    # do something here
else:
    # more conditions
    if b2:
        # do something here
    else:
        # more conditions
      if b3:
          # do something here
      else:
          # ...
\end{lstlisting}

This situation is rather common, so instead we have \code{elif}:

\begin{lstlisting}[language=Python]
if b1:
    # do something here
elif b2:
    # do something here
elif b3:
    # do something here
# ...
else:
    # finally, if everything fails, here
\end{lstlisting}

\subsection{CodingBat}

I mentioned at the beginning of the book that many of the exercises
are just to complete CodingBat exercises. This is because CodingBat
will check your answers for you, and give you immediate feedback. You
have \emph{almost} enough information to do the first one. There's one
critical piece of information missing, and that's the notion of a
\term{function}.

The syntax for functions is a bit difficult to explain. It will be
easier if I just write a few functions, then let you figure things
out.  To illustrate, I'll do the first couple of CodingBat exercises,
then leave others in the exercises.

\begin{example}
  (This is from \url{http://codingbat.com/prob/p173401}).

  We are given two variables: \code{weekday} and \code{vacation}, both
  of which are Booleans. We want to write a function that determines
  whether or not we sleep in. If it is the weekend (i.e. \code{not
    weekday}), or we are on vacation, then we sleep in. Else, we don't

  \begin{solution}
    CodingBat gives you the beginning of the function:

\begin{lstlisting}[language=Python]
def sleep_in(weekday, vacation):
    # your code goes here
\end{lstlisting}
    You need to write something in the body that, at the end, returns
    a Boolean determining whether or not we sleep in.

    A na\"ive approach is to do this:

    \pyfile{code/codingbat/warmup1/sleep_in_naive.py}

    and that does work (see \cref{fig:sleep_in-naive}). However, we've
    accidentally created a redundancy. If you ever find yourself doing
    this:

    \lstpy{if-x-return-true.py}

    That can actually be simplified into

    \lstpy{return-some-boolean.py}

    Therefore, a better solution is:

    \pyfile{code/codingbat/warmup1/sleep_in.py}

    This gives the same result (see \cref{fig:sleep_in}).
  \end{solution}
\end{example}

\begin{figure}[h]
  \centering
  \answergraph{images/sleep_in-naive.png}
  \caption{Our na\"ive approach to \code{sleep_in()}.}
  \label{fig:sleep_in-naive}
\end{figure}
\begin{figure}[h]
  \centering
  \answergraph{images/sleep_in.png}
  \caption{Our non-na\"ive approach to \code{sleep_in()}.}
  \label{fig:sleep_in}
\end{figure}

\begin{example}
  (From \url{http://codingbat.com/prob/p120546}).

  \begin{quote}
    We have two monkeys, a and b, and the parameters \code{a_smile}
    and \code{b_smile} indicate if each is smiling. We are in trouble
    if they are both smiling or if neither of them is smiling. Return
    \code{True} if we are in trouble.
  \end{quote}

  \begin{solution}
    There are two things, which can be combined with \code{or}:

    \begin{enumerate}
    \item both monkeys smiling (\code{a_smile and b_smile});
    \item neither monkey smiling (\code{(not a_smile) and (not
        b_smile)}).
    \end{enumerate}

    Therefore, our result is

    \pyfile{code/codingbat/warmup1/monkey_trouble.py}

    As you can see in \cref{fig:monkey_trouble}, this works!
  \end{solution}
\end{example}

\begin{figure}[h]
  \centering
  \answergraph{images/monkey_trouble.png}
  \caption{The result of running our \code{monkey_trouble} solution in
    CodingBat.}
  \label{fig:monkey_trouble}
\end{figure}

\subsection{Exercises}

\begin{exercise}
  Fill in \cref{tbl:truth-table-and}.
\end{exercise}
\begin{exercise}
  Fill in \cref{tbl:truth-table-or}.
\end{exercise}
\begin{exercise}
  \label{exc:and-comm}
  Do you think the following property is true?

  \emph{For all Booleans \code{a} and \code{b}, \code{a and b} equals
    \code{b and a}.}

  Check your truth table to see.
\end{exercise}
\begin{exercise}
  Do the same as \cref{exc:and-comm}, but for \code{or}.
\end{exercise}
\begin{exercise}
  \label{exc:and-assoc}
  Do you think the following property is true?

  \emph{For all Booleans \code{a}, \code{b}, and \code{c} \code{a and
      (b and c)} equals
    \code{(a and b) and c)}.}

  Constructing a truth table here would require 3 dimensions, so just
  convince yourself whether or not it's true, maybe trying things in
  the REPL.
\end{exercise}
\begin{exercise}
  Do the same as \cref{exc:and-assoc}, but for \code{or}.
\end{exercise}
\begin{exercise}
  \label{exc:de-morgan-table-1}
  Build two truth tables for \cref{thm:de-morgan-1}. That is, build
  one for \code{not (a and b)}, then build a separate truth table for
  \code{(not b) or (not a)}, and then verify that they are identical.

  \begin{center}
    \begin{tabu}{r|c|c}
      \code{not (a and b)} & \code{True} & \code{False} \\
      \tabucline \\
      \code{True} && \\
      \tabucline \\
      \code{False} && \\
    \end{tabu}
  \end{center}
  \begin{center}
    \centering
    \begin{tabu}{r|c|c}
      \code{(not a) or (not b)} & \code{True} & \code{False} \\
      \tabucline \\
      \code{True} && \\
      \tabucline \\
      \code{False} && \\
    \end{tabu}
  \end{center}
\end{exercise}
\begin{exercise}
  \label{exc:de-morgan-table-2}
  Build two truth tables for \cref{thm:de-morgan-2}, in similar fashion
  to \cref{exc:de-morgan-table-1}:

  \begin{center}
    \centering
    \begin{tabu}{r|c|c}
      \code{not (a or b)} & \code{True} & \code{False} \\
      \tabucline \\
      \code{True} && \\
      \tabucline \\
      \code{False} && \\
    \end{tabu}
  \end{center}

  \begin{center}
    \centering
    \begin{tabu}{r|c|c}
      \code{(not a) and (not b)} & \code{True} & \code{False} \\
      \tabucline \\
      \code{True} && \\
      \tabucline \\
      \code{False} && \\
    \end{tabu}
  \end{center}
\end{exercise}
\begin{exercise}
  Write a program that takes a number (via \code{input()}), and prints
  out whether or not it's greater than $34$.
\end{exercise}
\begin{exercise}
  Construct two truth tables to convince yourself that these two
  things are the same.

  \lstpy{if-x-return-true.py}

  \begin{center}
    \begin{tabu}{r|c|c}
      \code{if/else} & \code{True} & \code{False} \\
      \tabucline \\
      \True && \\
      \tabucline \\
      \False && \\
    \end{tabu}
  \end{center}

  \lstpy{return-some-boolean.py}

  \begin{center}
    \begin{tabu}{r|c|c}
      \code{return} & \code{True} & \code{False} \\
      \tabucline \\
      \True && \\
      \tabucline \\
      \False && \\
    \end{tabu}
  \end{center}
\end{exercise}

\begin{exercise}
  Complete \url{http://codingbat.com/prob/p141905}. (\code{sum_double}).
\end{exercise}
\begin{exercise}
  Complete \url{http://codingbat.com/prob/p124984}. (\code{makes10}).
\end{exercise}

\subsection{Lists}